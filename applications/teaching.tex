\documentclass[10pt, a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[left=1.00in, right=1.00in, top=1.00in, bottom=1.00in]{geometry}
\author{Andrew Rosen}
\title{Teaching Philosophy}
\date{}
\begin{document}
\maketitle
	
I consider teaching Computer Science to be the most enjoyable and rewarding thing I do.
Computer Science itself has the privilege of simultaneously being both an old and new subject.
Computer Science is as old as mathematics and algorithms, much like astronomy is as old as the first human who decided to look at the stars.
Our subject is also new, as computers are a relatively recent invention in human history and the formal study of algorithms only truly began in the previous century.

Computer Science is a large field with many applications and that makes it particularly exciting both to learn and teach.
I often tell students that I chose Computer Science for my undergraduate degree because I had no idea what I wanted to do, but I knew that Computer Science and programming would give me the power to choose.
%If I wanted to work for a large business, I could.
%If I wanted to do scientific research in Physics or Biology, Computer Science would give me the tools to be successful.
This is why I love teaching Computer Science:  I can engage with a wide variety of students, each with unique backgrounds and widely varying aspirations.

With this shear breadth comes a challenge - Computer Science can be very difficult to teach and for students to learn.
I posit three reasons for this.

The first factor is that Computer Science is a completely new and foreign field for the vast majority of students.
Computer Science courses most closely resemble mathematics courses, but this is a result of how much math CS draws upon.
To learn programming and Computer Science requires you to learn a very methodical way of thinking and constructing algorithms, and this is a task that is unfortunately is lacking in student's primary education.

The second is stringent requirements of assignments.
There is no other subject where the expectation is that homework is completely correct.
Partial credit is minimal at best.
This can be quite intimidating to the novice programmer.

The third is that you are your own worst enemy when you program.
A single misplaced brace or missing equals sign can cause hours of mind-numbingly agonizing debugging.
No programmer is immune to this; everyone makes mistakes.

I address these challenges, I teach using a wide variety of approaches.
I believe the best way to learn programming is not by watching someone lecture about code using a whiteboard, but by actually programming.
Thus, I live-code in class.
This achieves a number of objectives.

By programming in class and prompting students for input, I am able to use the lecture time to get students coding, albeit vicariously.
It makes programming feel more real and less theoretical.

One of the reasons that live coding is not always done is because of the potential for errors.
However, I believe these errors are a valuable part of the learning process.
By making mistakes, intentionally or unintentionally, I help students become accustomed to the debugging process they will have to do themselves.
I believe that seeing an ostensible expert make mistakes and correct them makes coding much less intimidating.
As the course progresses, students become more comfortable with correcting any mistakes they see.


While I believe in a highly practical education, I believe that no Computer Science student be as successful as possible without a rigourous theoretical understanding of the 


Reading powerpoint slides is not teaching 
I create my own teaching aids, and make them available to the class.



















I am available for office hours a while.


I judge my success in having students learn the material when they feel comfortable enough to ask and  answers questions in class and get over the fear of embarrassment.


Balaance student use of technol








\end{document}