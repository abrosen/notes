%TODO: godfrey2005heterogeneity
\chapter{Proposed Work}
\label{chapter:experiments}


\section{DHT Framework}
As mentioned in Chapter \ref{chapter:intro}, our plan is to create a highly configurable and easy to use DHT framework based off the DHT abstractions we have discovered.

\begin{itemize}
	\item This will be done jointly with Brendan.
	\item The language used will either be Python3 or Go
	\begin{itemize}
		\item Python3 is easily to read and write and has support for coroutines.  However, we have to deal with the Global Interpreter Lock.
		\item Go is safer than Python and is designed for concurrency.
	\end{itemize}
	\item We will be using test driven design.
	\item The goal of this step is \textbf{not} to create a DHT, but to create an easily extensible abstract framework anyone to make DHTs.
	\item The abstraction comes from implementing the relationship we found between DHT spheres of responsibility and Voronoi tessellations
	
\end{itemize}


\section{Distributed DHT Computing}


Our goal is to further develop ChordReduce and release a complete version: a DHT based platform for solving embarrassingly parallel problems using DHTs.
The steps involved in this are listed below.

\begin{itemize}
	
	\item We will use the above framework to implement a few of the more popular DHTs.
	\begin{itemize}
		\item This will serve as both examples for home to implement our framework as well and the building blocks for the next step.
	\end{itemize}
	\item Implement MapReduce on these DHTs and compare their performances.
	\item Create a  processor scoring mechanism for creating virtual nodes.
	\begin{itemize}
		\item This score is a relative score, since the amount of work a node can carry is determined by the amount other nodes can carry.
		\item The score is based off of processor speed (maybe using Bogomips as the default for a while).
		\item This is compared to the scores of neighboring nodes  of all the node's replicas and should give a gauge of the node's relative processing power.
		\item This ties in directly to the autonomous load balancing.
	\end{itemize}
	\begin{itemize}
		\item The emphasis is our framework is optimized for robustness over everything else.
	\end{itemize}
	
\end{itemize}



\section{Autonomous load balancing}

The questions and goals here are straightforward:
\begin{itemize}
	\item Further establish the phenomena exists.
	\item We stumbled across this phenomena with a brute force method and still got promising results.  
	Can we create a more accurate and mean
	\item Can this phenomena be stochastically modeled or otherwise predicted via theoretical analysis?
	\item In what contexts can this be used for DHTs?  Distributed computing?  Replication for file sharing?
	
\end{itemize}




Perhaps we need an entirely new node type, a sentinel that exists merely for checking traffic conditions and load.
This also breaks how we think of normal nodes.

It may also be that the virtual nodes for load balancing show not keep long hops, so they don't become inundated with routing messages.

One assertion is why not use some kind of mechanism for ensuring even distribution of nodes?
The issue there is that our solutions for doing this are centralized distribution or a spring-model mechanism (or the binning mechanism of Dynamo, but the paper is a bit roundabout on how to do that).

\subsubsection{Brainstormed Methods}
%My proposed scheme works like this: a node that determines that it can carry more of the network's weight.
%How it does this is a problem that needs to be solved.
%Regardless, once it has made this determination, the node choose an area in the keyspace for it to inject a replica into.


\begin{itemize}
	\item Passive load balancing (guessing):  no actual communication.
	Here the node looks at the values it can mash, looks at the for that value neighbors, and if the size of that region is larger than average (as reported by the node's short )
	\item Traffic watching using IRM
	\item Invitition:  If the node detects its region is too large; it invites other nodes to join.
\end{itemize}

